9. SQL -- дополнительные возможности
9.1. Работа с копиями таблицы

Команду SELECT можно применять к нескольким копиям одной и той же таблицы. При этом после ключевого слова FROM имя таблицы записывается несколько раз, причем сопровождается произвольным идентификатором. Он используется для различения копий таблицы в запросе. В качестве префикса полей используют уже не имя таблицы, а эти идентификаторы (так называемые переменные корреляции).

Использование объединения таблицы с нею самой полезно, если в ней надо отыскать связанные элементы. Пусть требуется найти всех заказчиков с одинаковыми контактными должностями (поле ContactTitle). Для этого надо сравнить все записи таблицы -- каждую с каждой. Язык SQL подобные манипуляции над данными (множествами) выполняет автоматически:

SELECT t1.ContactName, t2.ContactName, t2.ContactTitle 
FROM Customers t1, Customers t2 
WHERE (t1.ContactTitle = t2.ContactTitle)
ORDER BY t2.ContactTitle;
Будут выданы все пары контактных лиц, у которых совпадает название должности.



Обычно подобные запросы к копиям таблиц делаются, чтобы выявить в ней различные несогласованности, избыточность информации и т. д.

Переменные корреляции особо важны, если требуется сформировать не просто список результатов, а набор комбинаций, удовлетворяющих заданному условию. Например, для определенной работы требуется сформировать все варианты из трёх сотрудников, проживающих в Лондоне (поле City). В этом поможет следующее выражение:

SELECT t1.ContactName, t2.ContactName, t3.ContactName, t1.City 
FROM Customers t1, Customers t2, Customers t3 
WHERE (t1.City = 'London') AND (t1.City = t2.City) AND (t1.City = t3.City) 
AND (t1.CustomerID <> t2.CustomerID) AND 
(t1.CustomerID <> t3.CustomerID) AND 
(t2.CustomerID <> t3.CustomerID); 
Отмечу, что с помощью операций группировки мы не можем получить такой результат.

9.2. Проверка пустого запроса

Предложение EXISTS проверяет, выдает ли подзапрос хотя бы одну запись. Если выдаваемый им набор непустой, предложение EXISTS выдает значение "истина". Фактически это предложение определяет, пуст ли заданный набор. Команду EXISTS можно использовать с логической операцией NOT, если результат проверки требуется инвертировать.

Чаще всего предложение EXISTS применяется в запросах, где требуется сформировать список записей, связанных с другими таблицами. Например, пусть требуется показать все заказы, для которых стоимость товара (таблица Products, поле UnitPrice) больше или равна 200. Для этого лучше всего подходит предложение EXISTS, которое проверит, имеется ли для некоторого заказа непустой список товаров с нужной ценой.

SELECT * FROM [Order Details] t1 
WHERE EXISTS 
(SELECT * FROM Products t2 
WHERE t1.ProductID = t2.ProductID AND t2.UnitPrice >= 200);
Если вместо EXISTS мы запишем NOT EXISTS, то соответственно получим список товаров, цена которых ниже 200.

9.3. Проверка набора на наличие значений вложенным запросом

Предложение ANY проверяет, имеется ли в наборе, выданном подзапросом, хотя бы одно из заданных значений. Оно применяется только во вложенных запросах.

Например, требуется отобрать всех сотрудников (таблица Employees), для которых страна заказов (таблица Orders) соответствует их текущей стране.

Для этого надо проверить, какие записи таблицы Employees совпадают по значению поля Country (страна работы) со значением поля ShipCountry (страна поставки) таблицы Orders:

SELECT t1.FirstName, t1.LastName, t1.Country, t2.OrderDate 
FROM Employees t1, Orders t2 
WHERE t1.Country = ANY 
(SELECT ShipCountry FROM Orders); 
Предложение ALL противоположно по смыслу предложению ANY. Оно проверяет, равно ли заданное значение не какому-то одному, а каждому из значений тестируемого набора записей. Однако работает эта команда не совсем обычно. Выражение наподобие:

Country = ALL (SELECT ShipCountry FROM Orders)
выдаст значение "истина" только в случае, если все значения в столбце ShipCountry одинаковы, а такое маловероятно. Поэтому команда ALL обычно применяется не для проверки равенства, а для проверки неравенства.

Пусть требуется найти все заказы в странах, на которые не приходится ни один сотрудник. Соответствующий запрос можно записать так:

SELECT t1.FirstName, t1.LastName, t1.Country, t2.OrderDate 
FROM Employees t1, Orders t2 
WHERE t1.Country <> ALL 
(SELECT ShipCountry FROM Orders);
Выражение:

t1.Country <> ALL (SELECT ShipCountry FROM Orders)
истинно, если страна сотрудника (поле Country таблицы Employees) не соответствует ни одной из стран-поставщиков (ShipCountry) таблицы заказов.

В учебной базе таких сотрудников нету, но можно вручную временно подкорректировать в таблице Employees страну любого сотрудника, изменив её на произвольное значение, чтобы увидеть результат.

Важно:
-- EXISTS вообще конструкция в целом излишняя в SQL, всегда можно без неё обходиться.
-- Построчно работает сама WHERE в целом -- сперва конструируется произведение таблиц из FROM, потом на него накладывается ограничение WHERE -- исключаются записи, для которых предикат WHERE ложен.
Что лучше выбрать, это скорее вопрос эффективности: надо смотреть, как в конкретной СУБД реализована та или иная фича, насколько большие получаются промежуточные запросы, и т. п.

-- Разница между ANY и IN на практике по большому счёту лишь в том, что для ANY можно использовать операции сравнения = > <

9.4. Задания

9.4.1. Найдите все пары из разных заказчиков (Customers), для которых не задан регион (поле Region).

9.4.2. Найдите вложенным запросом список заказов (Orders), в котором у заказчиков (Customers) регион не пуст (поле Region).

9.4.3. Немного условный, но показательный пример. Найдите все заказы (таблица Orders), цена за доставку товара которых (Freight) превышает цену любого товара (поле UnitPrice, таблица Products).

Решение задания 8
8.3.1. Сформируйте список названий товаров (таблица Products) с указанием для каждого из них соответствующей категории (таблица Categories).

SELECT Products.ProductName, Categories.CategoryName
FROM Products, Categories 
WHERE Products.CategoryID = Categories.CategoryID
8.3.2. Организуйте эквисоединение, которое выводит цену и названия тех товаров, для которых цена за единицу (UnitPrice) в таблице Order Details меньше 20.

SELECT Products.ProductName, [Order Details].UnitPrice
FROM Products, [Order Details] 
WHERE Products.ProductID = [Order Details].ProductID AND 
      [Order Details].UnitPrice < 20
8.3.3. Добавьте к предыдущему запросу третью таблицу Categories, и выведите в дополнение к названию товара его категорию.

SELECT Products.ProductName, [Order Details].UnitPrice, Categories.CategoryName
FROM Products, [Order Details], Categories 
WHERE Products.ProductID = [Order Details].ProductID AND
      Products.CategoryID = Categories.CategoryID AND
      [Order Details].UnitPrice < 20
